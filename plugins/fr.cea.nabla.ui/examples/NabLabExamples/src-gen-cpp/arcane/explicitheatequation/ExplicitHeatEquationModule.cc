/* DO NOT EDIT THIS FILE - it is machine generated */

#include "ExplicitHeatEquationModule.h"
#include <arcane/Concurrency.h>

using namespace Arcane;

/******************** Free functions definitions ********************/

namespace explicitheatequationfreefuncs
{
Real norm(ConstArrayView<Real> a)
{
	return std::sqrt(explicitheatequationfreefuncs::dot(a, a));
}

Real dot(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	Real result(0.0);
	for (Integer i=0; i<x; i++)
	{
		result = result + a[i] * b[i];
	}
	return result;
}

Real det(Real2 a, Real2 b)
{
	return (a[0] * b[1] - a[1] * b[0]);
}

ConstArrayView<Real> sumR1(ConstArrayView<Real> a, ConstArrayView<Real> b)
{
	return a + b;
}

Real minR0(Real a, Real b)
{
	return std::min(a, b);
}

Real sumR0(Real a, Real b)
{
	return a + b;
}

Real prodR0(Real a, Real b)
{
	return a * b;
}
}


/******************** Module entry points ********************/

void ExplicitHeatEquationModule::init()
{
	computeFaceLength(); // @1.0
	computeV(); // @1.0
	initD(); // @1.0
	initTime(); // @1.0
	initXc(); // @1.0
	computeDeltaTn(); // @2.0
	computeFaceConductivity(); // @2.0
	initU(); // @2.0
	setUpTimeLoopN(); // @2.0
	computeAlphaCoeff(); // @3.0
	executeTimeLoopN(); // @4.0
}

void ExplicitHeatEquationModule::compute()
{
	computeTn(); // @1.0
	updateU(); // @1.0
}


/******************** Module methods ********************/

/**
 * Job computeFaceLength called @1.0 in simulate method.
 * In variables: X
 * Out variables: faceLength
 */
void ExplicitHeatEquationModule::computeFaceLength() noexcept
{
	Parallel::Foreach(getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			Real reduction0(0.0);
			ENUMERATE_NODE(p, getNodesOfFace(fId))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::norm(X[p] - X[p]));
			}
			faceLength[f] = 0.5 * reduction0;
		}
	});
}

/**
 * Job computeTn called @1.0 in executeTimeLoopN method.
 * In variables: deltat, t_n
 * Out variables: t_nplus1
 */
void ExplicitHeatEquationModule::computeTn() noexcept
{
	t_nplus1 = t_n + deltat;
}

/**
 * Job computeV called @1.0 in simulate method.
 * In variables: X
 * Out variables: V
 */
void ExplicitHeatEquationModule::computeV() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real reduction0(0.0);
			ENUMERATE_NODE(p, getNodesOfCell(cId))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, explicitheatequationfreefuncs::det(X[p], X[p]));
			}
			V[c] = 0.5 * reduction0;
		}
	});
}

/**
 * Job initD called @1.0 in simulate method.
 * In variables: 
 * Out variables: D
 */
void ExplicitHeatEquationModule::initD() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			D[c] = 1.0;
		}
	});
}

/**
 * Job initTime called @1.0 in simulate method.
 * In variables: 
 * Out variables: t_n0
 */
void ExplicitHeatEquationModule::initTime() noexcept
{
	t_n0 = 0.0;
}

/**
 * Job initXc called @1.0 in simulate method.
 * In variables: X
 * Out variables: Xc
 */
void ExplicitHeatEquationModule::initXc() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real2 reduction0({0.0, 0.0});
			ENUMERATE_NODE(p, getNodesOfCell(cId))
			{
				reduction0 = explicitheatequationfreefuncs::sumR1(reduction0, X[p]);
			}
			Xc[c] = 0.25 * reduction0;
		}
	});
}

/**
 * Job updateU called @1.0 in executeTimeLoopN method.
 * In variables: alpha, u_n
 * Out variables: u_nplus1
 */
void ExplicitHeatEquationModule::updateU() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real reduction0(0.0);
			ENUMERATE_CELL(d, getNeighbourCells(cId))
			{
				reduction0 = explicitheatequationfreefuncs::sumR0(reduction0, alpha[c][d] * u_n[d]);
			}
			u_nplus1[c] = alpha[c][c] * u_n[c] + reduction0;
		}
	});
}

/**
 * Job computeDeltaTn called @2.0 in simulate method.
 * In variables: D, V
 * Out variables: deltat
 */
void ExplicitHeatEquationModule::computeDeltaTn() noexcept
{
	Real reduction0(numeric_limits<double>::max());
	ENUMERATE_CELL(c, getCells())
	{
		reduction0 = explicitheatequationfreefuncs::minR0(reduction0, V[c] / D[c]);
	}
	deltat = reduction0 * 0.24;
}

/**
 * Job computeFaceConductivity called @2.0 in simulate method.
 * In variables: D
 * Out variables: faceConductivity
 */
void ExplicitHeatEquationModule::computeFaceConductivity() noexcept
{
	Parallel::Foreach(getFaces(), [&](FaceVectorView view)
	{
		ENUMERATE_FACE(f, view)
		{
			Real reduction0(1.0);
			ENUMERATE_CELL(c1, getCellsOfFace(fId))
			{
				reduction0 = explicitheatequationfreefuncs::prodR0(reduction0, D[c1]);
			}
			Real reduction1(0.0);
			ENUMERATE_CELL(c2, getCellsOfFace(fId))
			{
				reduction1 = explicitheatequationfreefuncs::sumR0(reduction1, D[c2]);
			}
			faceConductivity[f] = 2.0 * reduction0 / reduction1;
		}
	});
}

/**
 * Job initU called @2.0 in simulate method.
 * In variables: Xc, u0, vectOne
 * Out variables: u_n
 */
void ExplicitHeatEquationModule::initU() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			if (explicitheatequationfreefuncs::norm(Xc[c] - vectOne) < 0.5) 
				u_n[c] = options.u0;
			else
				u_n[c] = 0.0;
		}
	});
}

/**
 * Job setUpTimeLoopN called @2.0 in simulate method.
 * In variables: t_n0
 * Out variables: t_n
 */
void ExplicitHeatEquationModule::setUpTimeLoopN() noexcept
{
	t_n = t_n0;
}

/**
 * Job computeAlphaCoeff called @3.0 in simulate method.
 * In variables: V, Xc, deltat, faceConductivity, faceLength
 * Out variables: alpha
 */
void ExplicitHeatEquationModule::computeAlphaCoeff() noexcept
{
	Parallel::Foreach(getCells(), [&](CellVectorView view)
	{
		ENUMERATE_CELL(c, view)
		{
			Real alphaDiag(0.0);
			ENUMERATE_CELL(d, getNeighbourCells(cId))
			{
				const Real alphaExtraDiag(deltat / V[c] * (faceLength[f] * faceConductivity[f]) / explicitheatequationfreefuncs::norm(Xc[c] - Xc[d]));
				alpha[c][d] = alphaExtraDiag;
				alphaDiag = alphaDiag + alphaExtraDiag;
			}
			alpha[c][c] = 1 - alphaDiag;
		}
	});
}
